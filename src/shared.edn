; template eth_getBlockByNumber call
(if (get _parameters :metamask)
  (defn __eth-get-block-by-number [block-number]
    (->
     (Msg "eth_getBlockByNumber")
     "(async () => { const res = await ethereum.request(" >= .request
     {"method" "eth_getBlockByNumber"
      "params" [block-number true]} (ToJson) (AppendTo .request)
     "); return JSON.stringify(res); })()" (AppendTo .request)
     .request (_Emscripten.EvalAsync) (FromJson)
     (ExpectTable) (Take "transactions") (ExpectSeq)))
  (defn __eth-get-block-by-number [block-number]
    (->
     {"jsonrpc" "2.0"
      "method" "eth_getBlockByNumber"
      "params" [block-number true]
      "id" 1} (ToJson)
     (Http.Post (get _parameters :gatewayURL)
                :Timeout 60) (FromJson)
     (ExpectTable) (Take "result") (ExpectTable) (Take "transactions") (ExpectSeq))))

; template eth_call
(if (get _parameters :metamask)
  (defn __eth-call [to data]
    (->
     "ethereum.request(" >= .request
     {"method" "eth_call"
      "params" [{"to" to "data" data} "latest"]} (ToJson) (AppendTo .request)
     ")" (AppendTo .request)
     .request (_Emscripten.EvalAsync)))
  (defn __eth-call [to data]
    (-> {"jsonrpc" "2.0"
         "method" "eth_call"
         "params" [{"to" to "data" data} "latest"]
         "id" 1} (ToJson)
        (Http.Post (get _parameters :gatewayURL)
                   :Timeout 60) (FromJson)
        (ExpectTable) (Take "result") (ExpectString))))

; template for block data fetching
(defn __fetch-block-data [logic]
  (-> (| (Take "block-number") = .block-number)
      (| (Take "frag-hash") = .frag-hash)
      (| (Take "expected-to") (String.ToLower) = .expected-to)
      (__eth-get-block-by-number .block-number) = .transactions
      (Sequence .result :Types Type.Bytes)
      .transactions
      (ForEach
       (-> (ExpectTable)
           (| (Take "to") = .to)
           (| (Take "input") = .input)
           .to (When (Is .expected-to)
                     (-> (Maybe logic)))))
      .result))

; eth block fetcher - to fetch call datas of fragment template upload calls
(defchain fetch-block-data-upload
  (__fetch-block-data (-> .input (ExpectString) (Slice :From 10)
                          ; decode input data to get hash, that's why true as 3rd param
                          (Eth.DecodeCall frag-abi "upload" true)
                          (| (Take 0) (ExpectBytes) = .immutableData)
                          (| (Take 1) (ExpectBytes) = .mutableData)
                          .immutableData (Hash.Keccak-256) (Slice :From 12) (ToBase58)
                          (When (Is .frag-hash) (-> .immutableData >> .result
                                                    .mutableData >> .result
                                                    (Return))))))

; eth block fetcher - to fetch call datas of fragment template update calls
(defchain fetch-block-data-update
  (__fetch-block-data (-> .input (ExpectString) (Slice :From 10)
                          ; decode input data to get hash, that's why true as 3rd param
                          (Eth.DecodeCall frag-abi "update" true)
                          ; in theory Take 0 is the fragment hash but we could have multiple updates per block
                          (| (Take 1) (ExpectBytes) = .mutableData)
                          .mutableData (Hash.Keccak-256) (Slice :From 12) (ToBase58)
                          (When (Is .frag-hash) (-> .mutableData >> .result
                                                    (Return))))))

(defchain fetch-block-data-entity
  (__fetch-block-data (-> .input
                          (| (ExpectString) (Slice :From 10) = .call-input)
                          (ExpectString) (Slice :To 10) (Log "method")
                          (Match ["0xb726f71b" ; update
                                  (-> .call-input (Eth.DecodeCall entity-abi "upload" true)
                                      (Take 0) (ExpectBytes) >> .result
                                      (Return))
                                  nil nil]))))

; utility function to load from chain or cache fragments
(defn __frag-load-cached [hash]
  (->
   hash = .b58-template-hash ; used in a shared path with entity loading
   ; TODO, check isReferencedBy
   (Maybe
    (->
     ; TODO, decide how to flag cached content for update after a mutation happened
     (ReadFile (str "cache/frag/" hash))
     (ExpectLike {"data" [(Bytes "") (Bytes "")] "owner" ""} :Unsafe true))
    (-> ; download worst case scenario
     hash (Log "Downloading")
     hash (FromBase58) >> .hashBytes
     .hashBytes (Eth.EncodeCall frag-abi "dataOf") (ToHex) >= .callData
     (__eth-call fragments .callData)
     (Eth.DecodeCall frag-abi "dataOf")
     (| (Take 0) (ExpectBytes) (BigInt) (BigInt.ToInt) (ToHex) = .immutable-block)
     (| (Take 1) (ExpectBytes) (BigInt) (BigInt.ToInt) (ToHex) = .mutable-block)
     (| (Take 2) (ExpectBytes) (ToHex) = .ipfs-runtime)
     ; fetch block with immutable data
     {"block-number" .immutable-block
      "frag-hash" hash
      "expected-to" fragments} (Do fetch-block-data-upload) = .first-result
     .mutable-block (If (Is "0x00") ; 0x00 means no data mutation happened
                        (-> .first-result)
                        (->
                         .first-result (Take 0) >> .new-result
                         .hashBytes (Eth.EncodeCall frag-abi "mutableDataHashOf") (ToHex) > .callData
                         (__eth-call fragments .callData)
                         (Eth.DecodeCall frag-abi "mutableDataHashOf") (Take 0) (ExpectBytes) = .env-hash
                         {"block-number" .mutable-block
                          "frag-hash" .env-hash
                          "expected-to" fragments} (Do fetch-block-data-update) (Take 0) >> .new-result
                         .new-result)) (Set .frag-result "data")
     .hashBytes (Eth.EncodeCall frag-abi "ownerOf") (ToHex) > .callData
     (__eth-call fragments .callData)
     (Eth.DecodeCall frag-abi "ownerOf") (Take 0) (ExpectString) (Set .frag-result "owner")
     .frag-result (WriteFile (str "cache/frag/" hash) :Flush true))
    :Silent true)))

(defn loop-chain [chain]
  (if (tick chain) (loop-chain chain) nil))

(defn run-chain [chain input]
  (do
    (prepare chain)
    (start chain (String input))
    (loop-chain chain)
    ; stop returns the output
    (stop chain)))

(defn load-file-chain [hash bytes]
  (Chain (if bytes "load-bytes" "load-string")
         (ExpectString) >= .file-name (Log "LOADING")
         ; try load regular file path
         ; if fails assume we are loading from chain
         ; and so use file-name + fragment hash
         (Maybe (->
                 base-folder (PrependTo .file-name)
                 .file-name (FS.Read :Bytes bytes))
                (-> hash (AppendTo .file-name)
                    .file-name (Hash.Keccak-256) (ToBase58) > .file-name
                    "cache/fs/" (PrependTo .file-name)
                    .file-name (FS.Read :Bytes bytes))
                :Silent true)))

(def load-string-chain (load-file-chain "" false))
(defn load-string [file-name] (read-var (run-chain load-string-chain file-name)))
(def load-bytes-chain (load-file-chain "" true))
(defn load-bytes [file-name] (run-chain load-bytes-chain file-name))

(defn load-fragment [write-files]
  (-> (| (Take 0) (Brotli.Decompress) (FromBytes) (ExpectTable) = .files
         (Take "_") (ExpectString) = .loaded-fragment-immutable >> .fragment-result)
      (| (Take 1) (Brotli.Decompress) (FromBytes) (ExpectTable)
         (Take "e") (ExpectString) = .loaded-fragment-mutable >> .fragment-result)
      (if write-files (->
                       (str tmp-folder "immutable.tmp.edn")
                       (FS.Write .loaded-fragment-immutable :Overwrite true)
                       (str tmp-folder "mutable.tmp.edn")
                       (FS.Write .loaded-fragment-mutable :Overwrite true)))
      .files (ForEach
              (->
               = .file
               (Take 0) (ExpectString) >= .file-name
               .file-name (WhenNot
                           (Is "_")
                           (Maybe (->
                                   .file (Take 1) (ExpectBytes) = .file-data
                                   .b58-template-hash (AppendTo .file-name)
                                   .file-name (Hash.Keccak-256) (ToBase58) > .file-name
                                   "cache/fs/" (PrependTo .file-name)
                                   .file-name (FS.Write .file-data))))))
      .fragment-result))

(defn frag [hash & args]
  (let [load-env (if (not (nil? (first args))) (first args) false)
        params (if (not (nil? (first (rest args)))) (first (rest args)) {})
        load-string-chain (load-file-chain hash false)
        load-string (fn* [file-name] (read-var (run-chain load-string-chain file-name)))
        load-bytes-chain (load-file-chain hash true)
        load-bytes (fn* [file-name] (run-chain load-bytes-chain file-name))
        downloader-chain (Chain "downloader"
                                (__frag-load-cached hash)
                                (Log "Fragment loaded")
                                (Take "data")
                                (load-fragment false))
        code (run-chain downloader-chain "")
        ast (read-var code)
        ; can be either String or Bytes (if bytes it's a binary asset)
        immutable (if (string? (first ast)) (str "(-> " (first ast) ")") (first ast))
        mutable (str "(do " (nth ast 1) ")")]
    (if load-env (eval (read-string mutable)))
    ; can be either String or Bytes (if bytes it's a binary asset and so pass as it is)
    (if (string? immutable) (eval (read-string immutable)) immutable)))

(defn __entity-load-cached [contract id]
  (->
   (Maybe
    (->
     (ReadFile (str "cache/entity/" contract "-" id))
     (ExpectBytesSeq)
     ;; (ExpectLike {"data" [(Bytes "") (Bytes "")] "owner" ""} :Unsafe true)
     )
    (-> ; download worst case scenario
     ; check if this contract is official if not crash
     [] (Eth.EncodeCall entity-abi "getLibrary") (ToHex) >= .callData
     (__eth-call contract .callData)
     (Eth.DecodeCall entity-abi "getLibrary")
     (Take 0) (ExpectString) (Assert.Is fragments true)

     ; fetch template hash
     [] (Eth.EncodeCall entity-abi "getTemplate") (ToHex) > .callData
     (__eth-call contract .callData)
     (Eth.DecodeCall entity-abi "getTemplate")
     (Take 0) (ExpectBytes) = .template-hash (Slice :From 12) (ToBase58) = .b58-template-hash
     [.template-hash] (Eth.EncodeCall frag-abi "dataOf") (ToHex) > .callData
     (__eth-call fragments .callData)
     (Eth.DecodeCall frag-abi "dataOf")
     (| (Take 0) (ExpectBytes) (BigInt) (BigInt.ToInt) (ToHex) = .immutable-block)
     (| (Take 2) (ExpectBytes) (ToHex) = .ipfs-runtime)
     ; fetch block with immutable data
     {"block-number" .immutable-block
      "frag-hash" .b58-template-hash
      "expected-to" fragments} (Do fetch-block-data-upload) = .first-result

     ; NFT actual data associated with id
     id (BigInt) (BigInt.ToBytes) = .bid
     [.bid] (Eth.EncodeCall entity-abi "getData") (ToHex) > .callData
     (__eth-call contract .callData)
     (Eth.DecodeCall entity-abi "getData")
     (| (Take 0) (ExpectBytes) = .env-hash)
     (| (Take 1) (ExpectBytes) (BigInt) (BigInt.ToInt) (ToHex) = .mutable-block)
     {"block-number" .mutable-block
      "frag-hash" .env-hash
      "expected-to" contract} (Do fetch-block-data-entity) (Take 0) = .entity-data
     [1 .entity-data] (Assoc .first-result)
     .first-result (WriteFile (str "cache/entity/" contract "-" id) :Flush true))
    :Silent true)))