
; DO NOT EDIT THIS FILE.
; Runtimes will always use their own starndard version and not this copy

; JS side injects a _parameters map here

(def _args (if (empty? *command-line-args*) {} (read-string (first *command-line-args*))))

(if (not (= platform "emscripten"))
  (do
    ; perform _parameters initilization here
    (def _parameters {:user (if (contains? _args :user) (get _args :user) "0x0000000000000000000000000000000000000000")
                      :immutable (if (contains? _args :immutable) (get _args :immutable) "immutable.edn")
                      :mutable (if (contains? _args :mutable) (get _args :mutable) "mutable.edn")
                      :windowTitle (if (contains? _args :windowTitle) (get _args :windowTitle) "Fragment")
                      :windowWidth (if (contains? _args :windowWidth) (get _args :windowWidth) 1024)
                      :windowHeight (if (contains? _args :windowHeight) (get _args :windowHeight) 768)
                      :isSVG false
                      :xrSupported false
                      :gatewayURL (if (contains? _args :gateway) (get _args :gateway) "https://cloudflare-eth.com")})
    (def _Emscripten.Eval Pass)
    (def _Emscripten.EvalAsync Pass)
    (def base-folder ""))
  ; else we are already running on emscripten
  (do
    ; TODO I think we can remove this.. need to test JS/WASM
    (def base-folder "/.hasten/")))

(def ipfs-gateway "https://ipfs.io")
(def ar-gateway "https://arweave.net")
(def fragments "0x7777014b5b09d56299cb0c4b2e23abd61e8a8a65")

(def frag-abi (slurp "FragmentTemplate.json"))
(def entity-abi (slurp "FragmentEntity.json"))

(load-file (str base-folder "shared.edn"))

(defn _decode-base64 []
  (-> (Replace ["-" "_"] ["+" "/"]) >= .b64
      (Count .b64) (Math.Mod 4)
      (Match
       [2 (-> "==" (AppendTo .b64))
        3 (-> "=" (AppendTo .b64))
        nil nil])
      .b64 (FromBase64)))

; ipfs uploader
(defn _upload-to-ipfs [type type-name]
  (Chain (str "upload" type-name "-to-ipfs")
         (let [boundary "----CB-IPFS-Upload-0xC0FFEE"
               gateways (vector "https://ipfs.infura.io:5001"
                                "https://ipfs.komputing.org")]
           (->
            >= .payload
            (str "--" boundary
                 "\r\nContent-Disposition: form-data; name=\"path\"\r\nContent-Type: "
                 type "\r\n\r\n")
            (PrependTo .payload)
            (str "\r\n--" boundary "--")
            (AppendTo .payload)
            gateways
            (TryMany
             (Chain
              "IPFS-Upload"
              >= .gateway
              "/api/v0/add?pin=true" (AppendTo .gateway)
              .payload
              (Http.Post .gateway
                         :Headers {"Content-Type" (str "multipart/form-data; boundary=" boundary)}
                         :Timeout 60))
             :Policy WaitUntil.SomeSuccess)
            (Take 0) (FromJson) (ExpectTable)
            (Take "Hash") (ExpectString)))))
(def upload-bytes-to-ipfs (_upload-to-ipfs "application/octet-stream" "bytes"))
(def upload-png-to-ipfs (_upload-to-ipfs "image/png" "png"))
(def upload-webm-to-ipfs (_upload-to-ipfs "video/webm" "webm"))

(defloop upload-screenshot
  (str base-folder "screenshot.png")
  (When (FS.IsFile)
        (->
         (| (Pause 2.0) ; ensure file is ready
            (| "globalThis.chainblocks.previewScreenShot()" (_Emscripten.Eval))
            (FS.Read :Bytes true)
            (BytesToString)
            (Do upload-png-to-ipfs) = .hash)
         (| (FS.Remove))
         .hash
         (Stop))))

(defloop upload-video
  (str base-folder "recorded-canvas-video.webm")
  (When (FS.IsFile)
        (->
         (| (Pause 2.0) ; ensure file is ready
            (FS.Read :Bytes true)
            (BytesToString)
            (Do upload-webm-to-ipfs) = .hash)
         (| (FS.Remove))
         .hash
         (Stop))))

(defchain ugly-shader
  (Regex.Replace #"\r" "") ; remove \r
  (Regex.Replace #"\/\*[^*]*\*+(?:[^/*][^*]*\*+)*" "/") ; remove multi line comments
  (Regex.Replace #"\/\/.*" "") ; remove one line comments
  (Regex.Replace #"\n\s*\n" "\n") ; remove empty lines
  (Regex.Replace #"\t+" #" ") ; remove tabs, replace with space
  (Regex.Replace #"  +" #" ") ; remove more than one space
  (Regex.Replace #"\( " "(") ; remove useless spaces
  (Regex.Replace #" \)" ")") ; remove useless spaces
  (Regex.Replace #"\)\s*\{" ") {") ; remove useless spaces
  (Regex.Replace #".*$" #"$&\n") ; fix eof
  )

(defn FColor
  [r g b a]
  (Color (* 255 r) (* 255 g) (* 255 b) (* 255 a)))

(def identity
  [(Float4 1 0 0 0)
   (Float4 0 1 0 0)
   (Float4 0 0 1 0)
   (Float4 0 0 0 1)])

(defblocks applyStyle []
  (Float2 15 15) (GUI.Style GuiStyle.WindowPadding)
  5.0 (GUI.Style GuiStyle.WindowRounding)
  (Float2 5 5) (GUI.Style GuiStyle.FramePadding)
  (Float2 12 8) (GUI.Style GuiStyle.ItemSpacing)
  (Float2 8 6) (GUI.Style GuiStyle.ItemInnerSpacing)
  25.0 (GUI.Style GuiStyle.IndentSpacing)
  15.0 (GUI.Style GuiStyle.ScrollbarSize)
  9.0 (GUI.Style GuiStyle.ScrollbarRounding)
  5.0 (GUI.Style GuiStyle.GrabMinSize)
  3.0 (GUI.Style GuiStyle.GrabRounding)
  (FColor 0.80 0.80 0.83 1.00) (GUI.Style GuiStyle.TextColor)
  (FColor 0.24 0.23 0.29 1.00) (GUI.Style GuiStyle.TextDisabledColor)
  (FColor 0.06 0.05 0.07 1.00) (GUI.Style GuiStyle.WindowBgColor)
  (FColor 0.07 0.07 0.09 1.00) (GUI.Style GuiStyle.ChildBgColor)
  (FColor 0.07 0.07 0.09 1.00) (GUI.Style GuiStyle.PopupBgColor)
  (FColor 0.80 0.80 0.83 0.88) (GUI.Style GuiStyle.BorderColor)
  (FColor 0.92 0.91 0.88 0.00) (GUI.Style GuiStyle.BorderShadowColor)
  (FColor 0.10 0.09 0.12 1.00) (GUI.Style GuiStyle.FrameBgColor)
  (FColor 0.24 0.23 0.29 1.00) (GUI.Style GuiStyle.FrameBgHoveredColor)
  (FColor 0.56 0.56 0.58 1.00) (GUI.Style GuiStyle.FrameBgActiveColor)
  (FColor 0.10 0.09 0.12 1.00) (GUI.Style GuiStyle.TitleBgColor)
  (FColor 1.00 0.98 0.95 0.75) (GUI.Style GuiStyle.TitleBgCollapsedColor)
  (FColor 0.07 0.07 0.09 1.00) (GUI.Style GuiStyle.TitleBgActiveColor)
  (FColor 0.10 0.09 0.12 1.00) (GUI.Style GuiStyle.MenuBarBgColor)
  (FColor 0.10 0.09 0.12 1.00) (GUI.Style GuiStyle.ScrollbarBgColor)
  (FColor 0.80 0.80 0.83 0.31) (GUI.Style GuiStyle.ScrollbarGrabColor)
  (FColor 0.56 0.56 0.58 1.00) (GUI.Style GuiStyle.ScrollbarGrabHoveredColor)
  (FColor 0.06 0.05 0.07 1.00) (GUI.Style GuiStyle.ScrollbarGrabActiveColor)
  (FColor 0.80 0.80 0.83 0.31) (GUI.Style GuiStyle.CheckMarkColor)
  (FColor 0.80 0.80 0.83 0.31) (GUI.Style GuiStyle.SliderGrabColor)
  (FColor 0.06 0.05 0.07 1.00) (GUI.Style GuiStyle.SliderGrabActiveColor)
  (FColor 0.10 0.09 0.12 1.00) (GUI.Style GuiStyle.ButtonColor)
  (FColor 0.24 0.23 0.29 1.00) (GUI.Style GuiStyle.ButtonHoveredColor)
  (FColor 0.56 0.56 0.58 1.00) (GUI.Style GuiStyle.ButtonActiveColor)
  (FColor 0.10 0.09 0.12 1.00) (GUI.Style GuiStyle.HeaderColor)
  (FColor 0.56 0.56 0.58 1.00) (GUI.Style GuiStyle.HeaderHoveredColor)
  (FColor 0.06 0.05 0.07 1.00) (GUI.Style GuiStyle.HeaderActiveColor)
  (FColor 0.00 0.00 0.00 0.00) (GUI.Style GuiStyle.ResizeGripColor)
  (FColor 0.56 0.56 0.58 1.00) (GUI.Style GuiStyle.ResizeGripHoveredColor)
  (FColor 0.06 0.05 0.07 1.00) (GUI.Style GuiStyle.ResizeGripActiveColor)
  (FColor 0.40 0.39 0.38 0.63) (GUI.Style GuiStyle.PlotLinesColor)
  (FColor 0.25 1.00 0.00 1.00) (GUI.Style GuiStyle.PlotLinesHoveredColor)
  (FColor 0.40 0.39 0.38 0.63) (GUI.Style GuiStyle.PlotHistogramColor)
  (FColor 0.25 1.00 0.00 1.00) (GUI.Style GuiStyle.PlotHistogramHoveredColor)
  (FColor 0.25 1.00 0.00 0.43) (GUI.Style GuiStyle.TextSelectedBgColor))

(defloop screenshot-grab-upload
  ; pause a bit on top to allow first iteration
  (Pause 2.0)
  ; wait JS side indefinitely here
  "globalThis.chainblocks.screenShotPromise" (_Emscripten.EvalAsync)
  ; ok we got something, let's do our job
  "globalThis.chainblocks.setCanUpload(false)" (_Emscripten.Eval)
  (str base-folder "screenshot.png") (GFX.Screenshot)
  (Msg "screenshot requested")
  (Detach upload-screenshot)
  (Wait upload-screenshot) >= .cid
  "globalThis.chainblocks.setScreenshotCID(\"" (PrependTo .cid) "\")" (AppendTo .cid)
  .cid (_Emscripten.Eval)
  "globalThis.chainblocks.setCanUpload(true)" (_Emscripten.Eval))

(defloop video-upload
  ; pause a bit on top to allow first iteration
  (Pause 2.0)
  ; wait JS side indefinitely here
  "window.chainblocks.videoCapturePromise" (_Emscripten.EvalAsync)
  ; ok we got something, let's do our job
  "globalThis.chainblocks.setCanUpload(false)" (_Emscripten.Eval)
  (Detach upload-video)
  (Wait upload-video) >= .cid
  "globalThis.chainblocks.setVideoCID(\"" (PrependTo .cid) "\")" (AppendTo .cid)
  .cid (_Emscripten.Eval)
  "globalThis.chainblocks.setCanUpload(true)" (_Emscripten.Eval))

(def Main
  (Chain
   "Main" :Looped :LStack ; notice large stack size

   ; Load a fragment from ethereum directly if the command line argument is given
   (if (contains? _args :fragment)
     (Setup
      ; KISS: Load the fragment from the ethereum network and write it into a file to load via ChainLoader
      (__frag-load-cached (get _args :fragment))
      (Take "data")
      (| (Take 0) (Brotli.Decompress) (FromBytes) (ExpectString) = .loaded-fragment-immutable)
      (| (Take 1) (Brotli.Decompress) (FromBytes) (ExpectTable) (Take "e") (ExpectString) = .loaded-fragment-mutable)
      (str base-folder "immutable.tmp.edn")
      (FS.Write .loaded-fragment-immutable :Overwrite true)
      (str base-folder "mutable.tmp.edn")
      (FS.Write .loaded-fragment-mutable :Overwrite true)))

   (if (and (contains? _args :entity) (contains? _args :entity-id))
     (Setup
      ; KISS: Load the fragment from the ethereum network and write it into a file to load via ChainLoader
      (__entity-load-cached (get _args :entity) (get _args :entity-id))
      (| (Take 0) (Brotli.Decompress) (FromBytes) (ExpectString) = .loaded-fragment-immutable)
      (| (Take 1) (Brotli.Decompress) (FromBytes) (ExpectTable) (Take "e") (ExpectString) = .loaded-fragment-mutable)
      (str base-folder "immutable.tmp.edn")
      (FS.Write .loaded-fragment-immutable :Overwrite true)
      (str base-folder "mutable.tmp.edn")
      (FS.Write .loaded-fragment-mutable :Overwrite true)))

   ; our main routine, manage a bgfx window and a chain loader
   (GFX.MainWindow
    :Title (get _parameters :windowTitle)
    :Width (get _parameters :windowWidth) :Height (get _parameters :windowHeight)
    :ClearColor (Color 7 7 7 255)
    ; prefer doing fullscreen setup JS side
    :Contents
    (->
     (Setup
      (applyStyle))
     ; branch some tasks
    ;;  (if (not (get _parameters :isSVG))
    ;;    (Branch [screenshot-grab-upload video-upload]))
     ; define out shader cache at this top level
     ; so to persist when user chain is reloaded
     (Table .shaders-cache)
     (Maybe
      (ChainLoader
       (Chain*
        ; if ethereum fragment is loaded use that
        (if (or (contains? _args :fragment) (and (contains? _args :entity) (contains? _args :entity-id)))
          (str base-folder "immutable.tmp.edn")
          (str base-folder (get _parameters :immutable)))

        ; bootstrap code to inject into the environment
        `(do
           (def _args ~_args)
           (def base-folder ~base-folder)
           (def _parameters ~_parameters)
           (def ipfs-gateway ~ipfs-gateway)
           (def ar-gateway ~ar-gateway)
           (def identity ~identity)
           (def frag-abi ~frag-abi)
           (def entity-abi ~entity-abi)
           (def fragments ~fragments)
           (load-file (str base-folder "shared.edn"))
           (load-file (str base-folder "utility.edn"))))
       :OnReload
       ; compress source to url format
       (->
        ; Don't save if we are running as fragment/entity player!
        (if (not (or (contains? _args :fragment) (and (contains? _args :entity) (contains? _args :entity-id))))
          (->
            ; do some reflection to evaluate the chain
            ; mark as tainted if we access the internet
           (| (Reflect.Blocks)
              (ForEach
               (->
                (Reflect.Name)
                (Match ["Http.Get" (-> true = .taint)
                        "Http.Head" (-> true = .taint)
                        "Http.Post" (-> true = .taint)
                        "Http.Put" (-> true = .taint)
                        "Http.Patch" (-> true = .taint)
                        "Http.Delete" (-> true = .taint)
                        nil nil]))))
           .taint ?? false
           (Match [true (-> "globalThis.chainblocks.tainted = true" (_Emscripten.Eval))
                   false (-> "globalThis.chainblocks.tainted = false" (_Emscripten.Eval))])
            ; unlock the next update
           "globalThis.chainblocks.unlockCode()" (_Emscripten.Eval)
            ; source
           (str base-folder (get _parameters :immutable))
           (When
            (FS.IsFile)
            (->
              ; compress the bytes as they are, we need to hash properly
             (FS.Read)
             (EDN.Uglify
               ; hooks
              ["Shader" ; minimize shaders
               (->
                 ; shaders might be complex and templated/macro etc
                 ; so just try if this works, if not pass the original
                = .sparams
                (Maybe
                 (->
                  .sparams (Take 0) (ExpectString) >> .sres ; Shader
                  .sparams (Take 1) (ExpectString) >> .sres ; var name
                  .sparams (Take 2) (ExpectString) >> .sres ; varyings
                  .sparams (Take 3) (ExpectString) (Do ugly-shader) >> .sres
                  .sparams (Take 4) (ExpectString) (Do ugly-shader) >> .sres
                  .sres)
                 (->
                  .sparams)
                 :Silent true))]) = .ugly-code
                  ; enviruments are not hashed here, so we can add structured data
                  ; the thing to keep in mind here is that we don't wanna depends on IPFS metadata AT ALL
             (get _parameters :windowTitle) (Set .environment "t")
             (get _parameters :windowWidth) (Set .environment "w")
             (get _parameters :windowHeight) (Set .environment "h")
             (slurp (get _parameters :mutable)) (EDN.Uglify) (Set .environment "e"); compress and write
             .ugly-code (ToBytes) (Brotli.Compress :Quality 11) = .compressed-bytes >> .local-fragment
             .environment (ToBytes) (Brotli.Compress :Quality 11) = .compressed-env >> .local-fragment
             .local-fragment (Set .frag-data "data")
             (get _parameters :owner) (Set .frag-data "owner")
             (Sub (->
                   (Await (->
                           (str base-folder "live-chain-binary")
                           (FS.Write .compressed-bytes :Overwrite true)
                           (str base-folder "live-chain-env-binary")
                           (FS.Write .compressed-env :Overwrite true)
                           .compressed-bytes
                           (Hash.Keccak-256)
                            ; take 20 bytes like ETH
                           (ToHex) (Slice :From 26) >= .eth-id
                           "0x" (PrependTo .eth-id)
                           .eth-id (HexToBytes) (ToBase58) = .b58-eth-id
                           (str base-folder "live-chain-eth-id")
                           (FS.Write .b58-eth-id :Overwrite true)
                            ; also cache locally in order to load it from other files!
                           (str base-folder "frag-cache/") >= .cached-name
                           .b58-eth-id (AppendTo .cached-name)
                           .frag-data (WriteFile .cached-name :Flush true)))
                   "globalThis.chainblocks.setCanUpload(true)" (_Emscripten.Eval)))
             (Count .compressed-bytes) (Log "compressed source size")
             (Count .compressed-env) (Log "compressed env size"))))))
       :OnError
       (-> ; unlock the next update
        "globalThis.chainblocks.unlockCode()" (_Emscripten.Eval)))
      ; if chain fails pause a bit
      (->
       (Pause 2.0)))))))

(if (= platform "emscripten")
  (do
    ; this one is ticked and scheduled from the JS side
    (set-global-chain Main)
    (decompress-strings)
    (let [Root (Node)
          blocks-info
          (let [info (map (fn* [name] {:name name :info (info name)}) (blocks))]
            (pr-str info))]
      (schedule
       Root
       (Chain
        "fill-blocks-info"
        ; write blocks info
        (str base-folder "blocks-info")
        (FS.Write blocks-info)))
      (run Root)))
  ; else
  (do
    (println "Starting")
    (defnode Root)
    (schedule Root Main)
    (run Root 0.016666666666667)))


